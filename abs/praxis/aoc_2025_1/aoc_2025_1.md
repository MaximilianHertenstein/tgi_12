---
title: Advent of Code
codebraid:
  jupyter: true
---

```{.java .cb-run}

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import static java.lang.IO.println;
import static java.lang.Math.abs;

public class Utils {

    static int computeChange(String command) {
        return Integer.parseInt(command.replace('L', '-').replace("R", ""));
    }

    static List<String> fileToLines(String fileName) throws IOException {
        var path = Path.of(fileName);
        return java.nio.file.Files.readAllLines(path);
    }

     static List<String> splitCommand(String command) {
        var acc = new ArrayList<String>();
        for (var i = 0; i <abs(computeChange(command)); i++){
            acc.add(command.charAt(0) + "1");
        }
        return acc;
    }

    static List<String> splitCommands(List<String> commands) {
        var acc = new ArrayList<String>();
        for (var command: commands){
            acc.addAll(splitCommand(command));
        }
        return acc;
    }

}



public class Dial  {

    public int pos;
    public int zeroCount;


    public Dial(){
        this(50,0);
    }

    public Dial(int pos, int zeroCount){
        this.pos = pos;
        this.zeroCount = zeroCount;
    }



    public static int normalize(int pos){
        int dialSize = 100;
        while (pos < 0){
            pos = pos + dialSize;
        }
        while (pos > 99){
            pos = pos - dialSize;
        }
        return pos;
    }

    public static int nextPos(String command, int pos){
        int change = Utils.computeChange(command);
        return normalize(pos + change);
    }


    public  void turn(String command){
        pos = nextPos(command, pos);
        if (pos == 0){
            zeroCount++;
        }
    }


    public void turn(List<String> commands){
        for (var command: commands){
            turn(command);
        };
    }


    public int zeroCount() {
        return zeroCount;
    }
}


public class Solutions {

    public static int countZerosAfterTurn(List<String> commands){
        var dial = new Dial();
        dial.turn(commands);
        return dial.zeroCount();
    }

    
    public static void solution1(String fileName) throws IOException {
        var lines = Utils.fileToLines(fileName);
        System.out.println(countZerosAfterTurn(lines));
    }

    public  static int countPointingToZeros(List<String> commands){
        var splittedCommands = Utils.splitCommands(commands);
        return countZerosAfterTurn(splittedCommands);
    }

    public static void solution2(String fileName) throws IOException {
        var lines = Utils.fileToLines(fileName);
        println(countPointingToZeros(lines));
    }

}
   


```



Definiere jede Klasse in einer eigenen Datei!



# Aufgabe – Hilfsklasse Utils anlegen

Erstelle die Klasse `Utils`. Alle Methoden in dieser Klasse sind öffentlich und statisch.


# Hinweis - Iteration über Strings

Die Methode `length` berechnet die Länge eines Strings.


```{.java .cb-nb line_numbers=false}
var s = "hello";
s.length()
```

Mit der Methode `charAt` kann auf den String an einer Stelle zugegriffen werden.

```{.java .cb-nb line_numbers=false}
s.charAt(1)
```

```{.java .cb-nb line_numbers=false}
for (int i = 0; i < s.length(); i++){
    println(s.charAt(i));
}
```


# Aufgabe – Drehkommando auswerten

Implementiere in der Klasse `Utils` die statische Methode `computeChange`.

Ein Drehkommando besteht aus:

- einem Buchstaben `L` oder `R`
- gefolgt von einer nicht-negativen ganzen Zahl

Bedeutung:

- `R` steht für eine Drehung **im Uhrzeigersinn**
- `L` steht für eine Drehung **gegen den Uhrzeigersinn**


Z.B. steht `R5` für eine Drehung um $5$ Schritte nach rechts.


Die Methode soll Drehungen im Uhrzeigersinn in positive Zahlen und Drehungen gegen den Uhrzeigersinn in negative Zahlen umwandeln.


```{.java .cb-nb line_numbers=false}
Utils.computeChange("R3");
```
```{.java .cb-nb line_numbers=false}
Utils.computeChange("L7");
```
```{.java .cb-nb line_numbers=false}
Utils.computeChange("R0");
```


**Hinweis:** Nutze `Integer.parseInt` um einen String in ein `Integer` zu konvertieren.


```{.java .cb-nb line_numbers=false}
Integer.parseInt("42")
```




# Hinweis – Datei zeilenweise einlesen

Erstelle in deinem Projekt (direkt im Projektordner und nicht in einem Unterordner!)  eine Textdatei `example_input.txt` mit dem folgenden Inhalt:

```
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
```

Ergänze die folgenden Importe.

```{.java .cb-nb line_numbers=false}
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Files;
```


Die statische Methode `of` der Klasse `Path` erzeugt ein Obbjekt der Klasse `Path`!


```{.java .cb-nb line_numbers=false}
var path = Path.of("example_input.txt")
```

Die statische Methode `readLines` der Klasse `Files` erzeugt gibt die Zeilen dieser Datei als Liste von Strings zurück!


```{.java .cb-nb line_numbers=false}
Files.readAllLines(path)
```

Bei allen Methoden, die diese Methode aufrufen, wird am Ende der Kopzeile die Ergänzung `throws IOException` benötigt.


# Aufgabe – Datei zeilenweise einlesen




Ergänze in der Klasse `Utils` die statische Methode `fileToLines`

Diese Methode wird ein Pfad als String übergeben. Sie soll:

- eine Textdatei mit diesem Pfad einlesen
- alle Zeilen in einer `List<String>` zurückgeben

```{.java .cb-nb line_numbers=false}
Utils.fileToLines("example_input.txt");
```




# Aufgabe – Klasse Dial definieren

Erstelle die Klasse `Dial`.

Diese Klasse modelliert ein Zifferblatt mit 100 Positionen (0–99).

Die Klasse besitzt:

- eine aktuelle Position `pos`
- einen Zähler `zeroCount`, der speichert, wie oft das Zifferblatt bis jetzt auf `0` gezeigt hat


# Aufgabe  – Konstruktoren für Dial

Implementiere zwei Konstruktoren:

1. Einen parameterlosen Konstruktor. Dieser setzt 
   - Startposition auf `50`
   - `zeroCount` auf `0`

```{.java .cb-nb line_numbers=false}
var dial = new Dial();
dial.pos
```
```{.java .cb-nb line_numbers=false}
dial.zeroCount
```

2. Einen Konstruktor mit zwei Parametern. Dieser erlaubt das Setzen von Startposition und Zähler



```{.java .cb-nb line_numbers=false}
var dial = new Dial();
dial.pos
```
```{.java .cb-nb line_numbers=false}
dial.zeroCount
```

# Aufgabe – Position normalisieren

Implementiere in `Dial` die statische Hilfsmethode `normalize`
Dieser Methode wird eine Position übergeben.
Sie gibt eine Position zurück, immer im Bereich `0` bis `99` liegt.

- Beim Überschreiten von `99` wird wieder bei $0$ begonnen
- Beim Überschreiten von `0` wird wieder bei $99$ begonnen


```{.java .cb-nb line_numbers=false}
Dial.normalize(100);
```
```{.java .cb-nb line_numbers=false}
Dial.normalize(103); 
```
```{.java .cb-nb line_numbers=false}
Dial.normalize(-1);
```
```{.java .cb-nb line_numbers=false}
Dial.normalize(-2);  
```
```{.java .cb-nb line_numbers=false}
Dial.normalize(412);  
```



# Aufgabe – Nächste Position berechnen

Implementiere in `Dial` die statische Methode `nextPos`. Dieser werden ein Befehl und eine Position übergeben.
Diese Methode soll die neue Position des Zeigers (ziwschen $0$ und $100$) berechnen.


```{.java .cb-nb line_numbers=false}
Dial.nextPos("R5", 10);
```
```{.java .cb-nb line_numbers=false}
Dial.nextPos("L20", 5);
```


**Hinweis:** Nutze `Utils.computeChange` und `normalize`!


# Aufgabe – Einzelnes Kommando ausführen

Implementiere in `Dial` die Methode `turn`. Dieser Methode wird ein Befehl übergeben.

Sie soll:

- die aktuelle Position verändern
- prüfen, ob die neue Position `0` ist
- in diesem Fall `zeroCount` erhöhen

```{.java .cb-nb line_numbers=false}
var dial = new Dial(70, 3);
dial.turn("L170");
dial.pos
```
```{.java .cb-nb line_numbers=false}
dial.zeroCount
```

```{.java .cb-nb line_numbers=false}
var dial = new Dial(95, 0);
dial.turn("R4");
dial.pos
```
```{.java .cb-nb line_numbers=false}
dial.zeroCount
```

**Hinweis:** Nutze `nextPos`!



# Aufgabe – Mehrere Kommandos ausführen

Implementiere in `Dial` die Methode `turn(List<String> commands)`

Diese Methode soll alle Kommandos in `commands` der Reihe nach ausführen.


```{.java .cb-nb line_numbers=false}
var dial = new Dial();
dial.turn(List.of("L50", "R10", "R90"));
dial.pos
```
```{.java .cb-nb line_numbers=false}
dial.zeroCount
```


# Aufgabe – Zugriff auf den Null-Zähler

Implementiere in `Dial` die Methode `zeroCount`

Sie gibt zurück, wie oft das Zifferblatt auf `0` gezeigt hat.

Beispiel:
```{.java .cb-nb line_numbers=false}
var dial = new Dial();
dial.turn(List.of("L50", "R50"));
dial.zeroCount(); 
```


# Aufgabe - Sichtbarkeit

Ändere die Sichtbarkeit der Eigenschaften und Methoden in der Klasse `Dial`. Alle Eigenschaften sollen privat sein. Nur die Methoden `turn(List<String> commands)`,  `zeroCount` un die Konsturktoren sollen öffentlich sein.


# Aufgabe – Klasse Solutions definieren

Erstelle die Klasse `Solutions`.



# Aufgabe – Null-Positionen zählen

Implementiere in `Solutions` die statische Methode `countZerosAfterTurn(List<String> commands)`

Die Methode soll:

- ein neues `Dial` erzeugen
- alle Kommandos in `commands` ausführen
- zurückgeben, wie oft die Position `0` nach einer Drehung erreicht wurde

Beispiel:
```{.java .cb-nb line_numbers=false}
Solutions.countZerosAfterTurn(List.of("L50", "R300"));
```


# Aufgabe – Lösung 1 implementieren

Implementiere in `Solutions` die Methode `solution1`. Dieser Methode wird ein Dateipfad als String übergeben.

Diese Methode soll:

- die Eingabedatei zeilenweise einlesen
- die Zeilen als Kommandos ausführen
- die Anzahl der Null-Treffer auf der Konsole ausgeben

Beispiel:
```{.java .cb-nb line_numbers=false}
Solutions.solution1("example_input.txt");
```


# Aufgabe - Belohnung einsammeln

Melde dich bei `https://adventofcode.com/` an. Lade deine Daten für die erste Aufgabe runter und speichere sie in einer Datei.
Werte die Daten mit `Solutions.solution1` aus und gib die Antwort ein.


# Aufgabe – Einzelnes Drehkommando zerlegen

Ergänze in der Klasse `Utils` die statische Methode `splitCommand(String command)`.

Die Methode erhält ein Drehkommando `"Lx"` oder `"Rx"` und gibt eine `List<String>` zurück.
Jeder Eintrag der Liste ist ein Einzelschritt (`"L1"` oder `"R1"`) mit der Richtung des übergebenen Befehls.
Alle Drehbefehle in der Liste entsprechen nacheinander ausgeführt dem übergebenen Drehbefehl.

```{.java .cb-nb line_numbers=false}
Utils.splitCommand("R3");
```
```{.java .cb-nb line_numbers=false}
Utils.splitCommand("L5");
```


# Aufgabe – Mehrere Kommandos zerlegen

Ergänze in der Klasse `Utils` die öffentliche statische Methode `splitCommands(List<String> commands)`.

Die Methode zerlegt alle Kommandos der übergebenen Liste in Einzelschritte.
Alle Einzelschritte werden in einer neuen Liste gesammelt und zurückgegeben.

```{.java .cb-nb line_numbers=false}
Utils.splitCommands(List.of("L2", "R3"));
```

**Hinweis:** Nutze die `ArrayList`-Methode `addAll`!



# Aufgabe – Zwischenpositionen zählen

Ergänze in der Klasse `Solutions` die statische Methode `countPointingToZeros(List<String> commands)`!

Die Methode zerlegt zuerst die übergebenen Kommandos in Einzelschritte.
Anschließend werden alle Schritte ausgeführt.
Zurückgegeben wird, wie oft das Zifferblatt während dieser Schritte auf `0` zeigt.

```{.java .cb-nb line_numbers=false}
Solutions.countPointingToZeros(List.of("L501"));
```

**Hinweis:** Nutze `splitcommand` und `countZerosAfterTurn`!

# Aufgabe – solution2 implementieren

Ergänze in der Klasse `Solutions` die Methode `solution2(String fileName)`

Die Methode liest die Datei zeilenweise ein, wertet die enthaltenen Kommandos mit
`countPointingToZeros` aus und gibt das Ergebnis auf der Konsole aus.

```{.java .cb-nb line_numbers=false}
Solutions.solution2("example_input.txt");
```

# Aufgabe

Werte mit der Methode `solution2` deine Eingabedaten von der AOC-Website aus.